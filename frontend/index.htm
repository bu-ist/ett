<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="ETT Home Page" content="">
    <meta name="author" content="Don Yurt, Warren Hennemuth">
    <title>ETT Home Page</title>

    <link rel="canonical" href="https://getbootstrap.com/docs/5.2/examples/jumbotron/">

    
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-rbsA2VBKQhggwzxH7pPCaAqO46MgnOM80zW1RWuH61DGLwZJEdK2Kadq2F9CUG65" crossorigin="anonymous">

        <!-- Favicons -->
    <meta name="theme-color" content="#712cf9">


    <style>
      .bd-placeholder-img {
        font-size: 1.125rem;
        text-anchor: middle;
        -webkit-user-select: none;
        -moz-user-select: none;
        user-select: none;
      }

      @media (min-width: 768px) {
        .bd-placeholder-img-lg {
          font-size: 3.5rem;
        }
      }

      .b-example-divider {
        height: 3rem;
        background-color: rgba(0, 0, 0, .1);
        border: solid rgba(0, 0, 0, .15);
        border-width: 1px 0;
        box-shadow: inset 0 .5em 1.5em rgba(0, 0, 0, .1), inset 0 .125em .5em rgba(0, 0, 0, .15);
      }

      .b-example-vr {
        flex-shrink: 0;
        width: 1.5rem;
        height: 100vh;
      }

      .bi {
        vertical-align: -.125em;
        fill: currentColor;
      }

      .nav-scroller {
        position: relative;
        z-index: 2;
        height: 2.75rem;
        overflow-y: hidden;
      }

      .nav-scroller .nav {
        display: flex;
        flex-wrap: nowrap;
        padding-bottom: 1rem;
        margin-top: -1px;
        overflow-x: auto;
        text-align: center;
        white-space: nowrap;
        -webkit-overflow-scrolling: touch;
      }
    </style>

    
  </head>
  <body>
    
    <main>
      <div class="container py-4">
        <header class="pb-3 mb-4 border-bottom">
          <a href="/" class="d-flex align-items-center text-dark text-decoration-none">
            <img src="https://societiesconsortium.com/wp-content/uploads/2019/05/SocietiesConsortium_on_SexualHarassmentin.svg" height="20%" width="20%" />
            <span class="fs-4 ps-4">Ethical Transparency Tool</span>
          </a>
        </header>

        <div class="p-5 mb-4 bg-light rounded-3">
          <div id="auth-section" class="container-fluid py-5">
            <h1 class="display-5 fw-bold" style="text-align:center">Welcome to the<br>Ethical Transparency Tool (ETT)</h1>
            <p class="text-justify fs-4" style="text-align:justify">ETT is designed to support AAU’s harassment prevention principles and the recommendations of NASEM’s June 2018 report on sexual harassment of women in academic science, engineering, and medicine by helping to create a norm of transparency about findings of misconduct against a person, across the higher-education and research ecosystem of societies, institutions of higher education, and other research organizations. This tool covers sexual, gender, and racial misconduct — as well as professional licensure, financial, and research misconduct to maximize its utility.</p>
            <center>
              <button id="btnSignin" class="btn btn-primary btn-lg" type="button" onclick="signIn()">Login</button>
              <button id="btnSignup" class="btn btn-primary btn-lg" type="button" onclick="signUp()">Signup</button>
            </center>
          </div>
          <div id="app-section" class="container-fluid py-5" style="display: none">
            <center>
              <p class="fs-4">Welcome, <span id="username"></span>!</p>
              <p><button class="btn btn-primary btn-lg" type="button" onclick="callApi()">Call API</button></p>
              <p><span id="apiResponse"></span></p>
            </center>            
            <button type="button" class="btn btn-danger" onclick="signOut()">Sign out</button>
          </div>
        </div>

        <footer class="pt-3 mt-4 text-muted border-top">
          &copy; 2023
        </footer>
      </div>
    </main>

  <script>

    const COGNITO_DOMAIN = 'COGNITO_DOMAIN_PLACEHOLDER';
    const CLIENT_ID = 'CLIENT_ID_PLACEHOLDER';
    const REDIRECT_URI = 'REDIRECT_URI_PLACEHOLDER';
    const USER_POOL_REGION = 'USER_POOL_REGION_PLACEHOLDER';
    const HELLO_WORLD_API_URI = 'HELLO_WORLD_API_URI_PLACEHOLDER';

    /**
     * Generate a code verifier
     */
    function generateCodeVerifier() {
      const codeVerifierLength = 64;
      const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~';
      let codeVerifier = '';

      for (let i = 0; i < codeVerifierLength; i++) {
        const randomIndex = Math.floor(Math.random() * chars.length);
        codeVerifier += chars.charAt(randomIndex);
      }

      return codeVerifier;
    }

    /**
     * Generate a base64 encoded string from input and return the url safe result.
     * NOTE: The base64 value is NOT url encoded, but any non-url compliant characters are stripped out.
     * Any platform implementing the oauth PKCE standard will account for this when processing the code challenge.
     */
    async function base64UrlEncode(sha256HashBuffer) {
      // Convert the SHA-256 hash to a base64 URL encoded string
      const sha256HashArray = Array.from(new Uint8Array(sha256HashBuffer));
      const base64UrlEncoded = btoa(String.fromCharCode(...sha256HashArray))
        .replace(/=/g, '')
        .replace(/\+/g, '-')
        .replace(/\//g, '_');

      return base64UrlEncoded;
    }

    function getRandomString(length) {
      const s = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
      return Array(length).join().split(',').map(
        function() { 
          return s.charAt(Math.floor(Math.random() * s.length)); 
        }
      ).join('');
    }

    /**
     * Generate a code challenge from the verifier
     */
    async function generateCodeChallenge(codeVerifier) {
      const encoder = new TextEncoder();
      const encodedVerifier = encoder.encode(codeVerifier);
      const codeChallenge = base64UrlEncode(await crypto.subtle.digest('SHA-256', encodedVerifier));
      return codeChallenge;
    }

    /**
     * Issue a code challenge to the cognito authorization endpoint as the first step in 
     * acquiring an authorization code to exchange for a JWT.
     */
    function initiateAuthorizationRequest(codeChallenge, state) {
      const params = {
        response_type: 'code',
        client_id: CLIENT_ID,
        redirect_uri: `https://${REDIRECT_URI}?action=login`,
        state: state,
        code_challenge: codeChallenge,
        code_challenge_method: 'S256'
      };
      
      const queryString = Object.keys(params).map(key => `${encodeURIComponent(key)}=${encodeURIComponent(params[key])}`).join('&');
      const authorizationUrl = `${COGNITO_DOMAIN}/oauth2/authorize?${queryString}`;
      
      window.location.href = authorizationUrl;
    }

    /**
     * Request an authorization code from the cognito authorization endpoint, with the original code verifier 
     * included as the second (and final) step in acquiring an authorization code to exchange for a JWT.
     * SEE: https://docs.aws.amazon.com/cognito/latest/developerguide/token-endpoint.html
     *      https://www.rfc-editor.org/rfc/rfc6749#section-3.2
     */
    function exchangeAuthorizationCode(callback) {
      const queryParams = new URLSearchParams(window.location.search);
      const authorizationCode = queryParams.get('code');
      const returnedState = queryParams.get('state')
      const savedState = window.sessionStorage.getItem("state");

      if(savedState !== returnedState) {
        throw Error("Probable session hijacking attack!");
      }

      if( ! authorizationCode) {
        throw Error('Authorization code not found in the URL.');
      }

      const codeVerifier = window.sessionStorage.getItem("code_verifier");
      const params = {
        grant_type: 'authorization_code',
        client_id: CLIENT_ID,
        redirect_uri: `https://${REDIRECT_URI}?action=login`,
        state: savedState,
        code: authorizationCode,
        code_verifier: codeVerifier
      };

      const formData = Object.keys(params).map(key => `${encodeURIComponent(key)}=${encodeURIComponent(params[key])}`).join('&');

      fetch(`${COGNITO_DOMAIN}/oauth2/token`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded'
        },
        body: formData
      })
      .then(response => response.json())
      .then(data => {
        AccessJwtCookie.setJwt(data.access_token);
        IDJwtCookie.setJwt(data.id_token);
        // RefreshJwtCookie.setJwt(data.refresh_token);
        callback();       
      })
      .catch(error => {
        console.error(`Authorization error: ${error}`);
      });
    }

    function signUp() {

      const params = {
        client_id: CLIENT_ID,
        response_type: 'code',
        scope: 'email+openid+phone',
        redirect_uri: encodeURIComponent(`https://${REDIRECT_URI}?action=signedup`)
      };

      const queryString = Object.keys(params).map(key => `${key}=${params[key]}`).join('&');
      const signUpUrl = `${COGNITO_DOMAIN}/signup?${queryString}`;
      window.location.href = signUpUrl;
    }

    /**
     * Authenticate with the cognito user pool in such a way as to reflect that it implements the
     * oauth PKCE standard. The final redirect should come with a JWT for all api access.
     */
    function signIn() {
      const codeVerifier = generateCodeVerifier();
      const state = getRandomString(12);

      // Save state and code_verifier in session storage
      const storage = window.sessionStorage;
      storage.clear();
      storage.setItem("state", state);
      storage.setItem("code_verifier", codeVerifier);

      generateCodeChallenge(codeVerifier).then(codeChallenge => {
        initiateAuthorizationRequest(codeChallenge, state);
      });
    }

    function signOut() {
      const params = {
        client_id: CLIENT_ID,
        logout_uri: encodeURIComponent(`https://${REDIRECT_URI}?action=logout`)
      };
      const queryString = Object.keys(params).map(key => `${key}=${params[key]}`).join('&');
      const signOutUrl = `${COGNITO_DOMAIN}/logout?${queryString}`;

      window.location.href = signOutUrl;
    }

    // https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-user-pools-using-the-access-token.html
    // https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-integrate-with-cognito.html
    function callApi() {
      fetch(HELLO_WORLD_API_URI, {
        method: 'POST',
        mode: "cors",
        credentials: 'include',
        headers: {
          'Authorization': `Bearer ${AccessJwtCookie.getJwt()}`,
          'Content-Type': 'application/json'
        }
      })
      .then((response) => {
        if (response.ok) {
          document.getElementById('apiResponse').innerHTML = `API response: ${JSON.stringify(response.body, null, 2)}`;
        } 
        else {
          document.getElementById('apiResponse').innerHTML = `Bad response: <br><textarea rows=5 cols=80>${JSON.stringify(response.body, null, 2)}</textarea>`;
        }
      })
      .catch((error) => {
        document.getElementById('apiResponse').innerHTML = `API error: <br><textarea rows=5 cols=80>${JSON.stringify({msg: error.message, stack: error.stack}, null, 2)}</textarea>`;
      });
    }

    /**
     * This function serves as a utility object for processing JWTs received from cognito and the cookies they are stored in.
     */
    const JwtCookie = function(cookieName) {
      this.getCookie = function() {
        const cookies = document.cookie.split(';').map(cookie => cookie.trim());
        for (const cookie of cookies) {
          if (cookie.startsWith(cookieName + '=')) {
            return cookie;
          }
        }
        return null; // JWT cookie not found
      };
      this.getJwt = function() {
        const cookie = this.getCookie();
        if(cookie) {
          return decodeURIComponent(cookie.substring(cookieName.length + 1));
        }
        return null; // JWT cookie not found
      };
      this.setJwt = function(jwt) {
        const secureFlag = window.location.protocol === 'https:' ? '; Secure' : '';
        const decodedToken = this.getDecodedToken(jwt);
        const expirationDate = new Date();
        if(decodedToken.expires_in) {
          expirationDate.setTime(expirationDate.getTime() + decodedToken.expires_in * 1000); // Convert expires_in from seconds to milliseconds
        } 
        else if(decodedToken.exp) {
          expirationDate.setTime(decodedToken.exp * 1000); // Convert the 'exp' claim to milliseconds
        }
        else {
          console.error("Cookie not set. No expiration claims found in jwt");
          return;
        }
        const expires = `; expires=${expirationDate.toUTCString()}`;
        const cookieValue = encodeURIComponent(jwt) + expires + secureFlag + '; SameSite=Strict';
        document.cookie = `${cookieName}=${cookieValue}`;
        // Now that the cookie is set and we have the JWT, we don't need the state and code verfier values anymore.
        const storage = window.sessionStorage;
        storage.clear();
      };
      this.clearJwt = function() {
        document.cookie = `${cookieName}=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;`;
      };
      this.getDecodedToken = function(jwt) {
        if(!jwt) jwt = this.getJwt();
        if(!jwt) return null;
        return JSON.parse(atob(jwt.split('.')[1])); // Decoding the token payload (middle part)
      };
      this.jwtExpired = function() {
        const decodedToken = this.getDecodedToken();
        const currentTime = new Date();
        if (decodedToken?.expires_in) {
          const expirationTime = new Date(decodedToken.iat * 1000 + decodedToken.expires_in * 1000);
          return currentTime >= expirationTime;              
        }
        else if(decodedToken?.exp) {
          const expirationTime = new Date(decodedToken.exp * 1000);
          return currentTime >= expirationTime;
        }
        return true;
      };
      /**
       * This function is an alternative to jwtExpired. The cookie expiration was set during its creation
       * based on the expiration of the jwt. Should be same result but more efficient to check expiration this way.
       */ 
      this.cookieExpired = function() {
        const cookie = this.getCookie();
        if(cookie) {
          const expirationTime = new Date(cookie.split(';').find(part => part.trim().startsWith('expires='))).getTime();
          const currentTime = new Date().getTime();
          return currentTime >= expirationTime;
        }
        console.log(`${cookieName} cookie is expired`);
        return true;
      };
      this.getUser = function() {
        const decodedToken = this.getDecodedToken();
        return {
          name: decodedToken.name
        };
      }
    };

    const IDJwtCookie= new JwtCookie('EttIdJwt')
    const AccessJwtCookie = new JwtCookie('EttAccessJwt');
    const RefreshJwtCookie = new JwtCookie('EttRefreshJwt');

    // Check the querystring for action=login on page load
    window.onload = () => {
      const queryParams = new URLSearchParams(window.location.search);
      const checkAuth = () => {
        if(!AccessJwtCookie.jwtExpired()) {
          const user = IDJwtCookie.getUser();
          document.getElementById('username').innerHTML = user.name;
          document.getElementById('auth-section').style.display = 'none';
          document.getElementById('app-section').style.display = 'block';
        }
        else if(!RefreshJwtCookie.jwtExpired()) {
          // TODO: Use the refresh token to restore access.
          console.log('Token refresh not implemented yet.');
        }
      }

      if(queryParams.get('action') === 'login') {
        exchangeAuthorizationCode(checkAuth);
      }
      else {
        if(queryParams.get('action') === 'signedup') {
          document.getElementById('btnSignup').style.display = 'none';
        }
        if(queryParams.get('action') === 'logout') {
          console.log('Sign out successful');
          // Remove JWT access and refresh tokens from cookies
          AccessJwtCookie.clearJwt();
          IDJwtCookie.clearJwt();
          RefreshJwtCookie.clearJwt();
        }
        checkAuth();
      }    
    };

  </script>
</script>   
</body>
</html>